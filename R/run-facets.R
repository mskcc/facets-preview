#' Run FACETS
#'
#' Runs FACETS on an input count file, with specified parameter settings.
#'
#' @param read_counts Read counts object, generated by `snp-pileup`.
#' @param cval Segmentation parameter, higher values for higher sensitivity.
#' @param diplogr Manual dipLogR value, if left empty `facets` finds the most likely sample baseline.
#' @param ndepth Minimum depth in normal to retain SNP, see `facets` help.
#' @param snp_nbhd Minimum basepair distance for SNPs, see `facets` help.
#' @param min_nhet Minimum number of heterozygous SNPs on segment required for clustering, see `facets` help.
#' @param genome Genome build.
#' @param seed Seed value for random number generation, set to enable full reproducibility.
#'
#' @return A list object with \code{out} and \code{fit} objects from Facets run.
#'
#' @examples
#' \dontrun{
#' library(pctGCdata)
#' run_facets(test_read_counts, cval = 500, genome = 'hg38')
#' }
#' 
#' @import facets
#' @import pctGCdata

#' @export run_facets
run_facets = function(read_counts,
                      cval = 100,
                      diplogr = NULL,
                      ndepth = 35,
                      snp_nbhd = 250,
                      min_nhet = 15,
                      genome = c('hg18', 'hg19', 'hg38', 'mm9', 'mm10'),
                      seed = 100) {
    
    # Check input 
    check_read_counts(read_counts)
    
    set.seed(seed)
    genome = match.arg(genome)
    
    # Run FACETS algorithm
    dat = facets::preProcSample(read_counts, ndepth = ndepth, het.thresh = 0.25, snp.nbhd = snp_nbhd, cval = 25,
                                gbuild = genome, hetscale = TRUE, unmatched = FALSE, ndepthmax = 1000)
    out = facets::procSample(dat, cval = cval, min.nhet = min_nhet, dipLogR = diplogr)
    fit = facets::emcncf(out)
    
    # Fix bad NAs
    fit$cncf = cbind(fit$cncf, cf = out$out$cf, tcn = out$out$tcn, lcn = out$out$lcn)
    fit$cncf$lcn[fit$cncf$tcn == 1] = 0
    fit$cncf$lcn.em[fit$cncf$tcn.em == 1] = 0
    
    # Generate output; note: keep this consistent with `get_facets_output_from_rdata`
    list(
        snps = out$jointseg,
        segs = fit$cncf,
        purity = as.numeric(fit$purity),
        ploidy = as.numeric(fit$ploidy),
        diplogr = out$dipLogR,
        alballogr = out$alBalLogR,
        flags = out$flags,
        em_flags = fit$emflags,
        loglik = fit$loglik,
        mafr_thresh = out$mafR.thresh
    )
}


# Helper functions ------------------------------------------------------------------------------------------------

# Check input, can be more elaborate
check_read_counts = function(rc) {
    missing_cols = setdiff(c('Chromosome', 'Position', 'NOR.DP', 'TUM.DP', 'NOR.RD', 'TUM.RD'), names(rc)) 
    if (length(missing_cols) > 0) {
        stop(paste('Input missing column(s)', paste(missing_cols, collapse = ', '), '.'), call. = FALSE)
    }
}

# constructs the facets_output object and returns
get_facets_output_from_rdata = function(rdata_file) {
  suppressWarnings(rm(out, fit))
  load(rdata_file)
  list(
    snps = out$jointseg %>% data.table,
    segs = fit$cncf %>% data.table,
    purity = as.numeric(fit$purity),
    ploidy = as.numeric(fit$ploidy),
    diplogr = out$dipLogR,
    alballogr = out$alBalLogR,
    flags = out$flags,
    em_flags = fit$emflags,
    loglik = fit$loglik,
    mafr_thresh = out$mafR.thresh
  )
}
